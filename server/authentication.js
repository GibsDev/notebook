/**
 * Sets up an authentication system for making requests to the server.
 * The exports of this file will include:
 * A router that handles the endpoints for authentication. (authRouter)
 * 
 * AND
 * 
 * A middleware function that is used for authenticating requests on other
 * endpoints/routes. (authenticate)
 * 
 * How it works:
 * The authRouter registers  the following endpoints:
 * 
 * POST /register
 * Registers a new (username and password) user
 * 
 * POST /login
 * Tries to validate credentials and sets a JWT cookie
 * 
 * POST /logout
 * Clears token cookies
 * 
 * GET /username/:username
 * Checks if a username has been registered
 * 
 * POST /link
 * Links a wallet to the (username and password) user that is currently logged in
 * 
 * The authentication process:
 * A user registers their username and password using a json ({ username, password }) POST to /register
 * A user makes a json ({ username, password }) POST to /login
 * The server validates the username and password
 * The server sends back a jwt token with the following info encoded (not visible to client)
 * {
 *     user (user id),
 *     id (token id),
 *     address (null in non web3),
 *     exp (epoch seconds), // generated by jwt sign
 *     iat // generated by jwt sign
 * }
 * The jwt is set in an HTTP only cookie via the server response
 * 
 * The authentication process using web3:
 * The client will ask the user to sign a message using their private key (wallet)
 * The client then makes POST request to /login { web_token: <token> }
 * The server will then validate the web3 token and generate a jwt token WITH the address
 * 
 * Why exchange web3 for jwt? It is not possible to invalidate a web3 token in
 * the event of a server crash. It will continues to be valid until expiration.
 * jwt tokens that are created on the server need to be verified with the server
 * secret which changes each time the server starts. This means that jwt tokens
 * that were handed out from a previous server isntance will not be valid when
 * the server restarts. There is a short term list of invalidated tokens that
 * the server keeps track of, but is lost when the server restarts. If a user
 * manages to get their hands on a web3 token (which would be stored in local
 * storage) and they can crash the server, they will be able to login with that
 * token as long as it has not expired. This could happen even if the actual
 * owner of the web3 token had logged out and invalidated the token id. The
 * invalidated token id list would have been cleared from server when it
 * crashed.
 * 
 */

const { v4: uuid } = require('uuid');
const express = require('express');
const jsonParser = express.json();
const jwt = require('jsonwebtoken');
const cookieParser = require('cookie-parser');
const rateLimit = require('express-rate-limit');
const Web3Token = require('web3-token');
const crypto = require('crypto');
const noteApp = require('./application.js');

const env = process.env.NODE_ENV || 'development';
const DEV = (env === 'development');

// Cookie id/keys
const JWT_COOKIE = 'jwt';

const authRouter = express.Router();
const secret = DEV ? 'dev' : crypto.randomBytes(64).toString('hex');


/**
 * An in memory structure that holds all invalidated tokens that have not yet
 * expired. Each authentication request checks if the token used is in this
 * structure and thus invalid. Every 10 minutes expired tokens will be pruned
 * (removed) from this strucutre as they are no longer valid anyway.
 * 
 * Maps token id => expiration
 * Expiration time is in seconds since epoch
 */
const invalidTokens = {};

/**
 * Invalid token pruning function every 10 minutes
 */
setInterval(() => {
    const currentEpochSeconds = Math.floor(Date.now() / 1000);
    for (const id of Object.keys(invalidTokens)) {
        const expiration = invalidTokens[id];
        if (expiration < currentEpochSeconds) {
            delete invalidTokens[id];
        }
    }
}, 1000 * 60 * 10);

/**
 * Rate limiting middleware used for some authentication endpoints to help
 * prevent brute forcing authentication. Each endpoint gets it's own rate
 * limiter.
 * @returns A new instance of a rate limiter
 */
function limiter() {
    return rateLimit({
        windowMs: 1000 * 60 * 5, // 5 minutes
        max: 15, // Request limit per `window`
        standardHeaders: true,
        legacyHeaders: false
    });
}

/**
 * @param {String} user The id of the user
 * @returns A JWT token
 */
function createJwtToken(user, address = null) {
    const tokenId = uuid();
    const token = jwt.sign({ user, id: tokenId, address }, secret, { expiresIn: '1d' });
    // Decode to get expiration date
    const decoded = jwt.verify(token, secret);
    const expDate = new Date(decoded.exp * 1000);
    return [token, expDate];
}

/**
 * Authentication middlware that looks for valid credentials in cookies and sets
 * req.auth accordingly
 */
async function authenticate(req, res, next) {
    cookieParser()(req, undefined, () => { });
    const token = req.cookies[JWT_COOKIE];
    try {
        const decoded = jwt.verify(token, secret);
        if (invalidTokens[decoded]) throw new Error('This token has been invalidated');
        req.auth = decoded;
    } catch (e) {
        return res.clearCookie(JWT_COOKIE).sendStatus(401);
    }
    return next();
}

/**
 * Invalidate all authentication tokens
 */
authRouter.post('/logout', authenticate, (req, res) => {
    if (req.auth && req.auth.id && req.auth.exp) {
        // Invalidate the token
        invalidTokens[req.auth.id] = req.auth.exp;
        res.clearCookie(JWT_COOKIE);
    }
    return res.sendStatus(200);
});

/**
 * Login with JWT authentication
 */
authRouter.post('/login', limiter(), jsonParser, async (req, res) => {
    if (!req.body) return res.status(400).send('Unable to parse json request body');
    if (req.body.username && req.body.password && !req.body.web3_token) {
        // Login with username and password
        const { username, password } = req.body;
        try {
            const { userId } = await noteApp(null).verifyLogin(username, password);
            const [token, expiration] = createJwtToken(userId);
            res.cookie(JWT_COOKIE, token, {
                expires: expiration,
                sameSite: 'strict',
                httpOnly: true
            });
            return res.sendStatus(200);
        } catch (e) {
            return res.sendStatus(401);
        }
    } else if (req.body.web3_token) {
        // Login with web3_token
        try {
            const { address } = await Web3Token.verify(req.body.web3_token);
            let user = await noteApp(null).getUserFromAddress(address);
            // Create a user for this wallet if necessary
            if (!user) {
                const newUser = await noteApp(null).createUser();
                user = await noteApp(newUser.id).linkWallet(address);
            }
            const [token, expiration] = createJwtToken(user.id, address);
            res.cookie(JWT_COOKIE, token, {
                expires: expiration,
                sameSite: 'strict',
                httpOnly: true
            });
            return res.sendStatus(200);
        } catch (e) {
            return res.status(401).send('Unable to validate web3_token');
        }
    } else {
        return res.status(400).send('Expected { username, password } or { web3_token }');
    }
});

/**
 * Register a new account for JWT authentication
 */
authRouter.post('/register', limiter(), jsonParser, async (req, res) => {
    if (!req.body) return res.status(400).send('Unable to parse json request body');
    const { username, password } = req.body;
    if (!username) return res.status(400).send('username not provided');
    if (!password) return res.status(400).send('passsword not provided');
    await noteApp(null).registerLogin(username, password);
    const user = await noteApp(null).createUser();
    await noteApp(null).linkLogin(username, user.id);
    return res.status(200).send(JSON.stringify({ username }));
});

/**
 * Check if a username exists
 */
authRouter.get('/username/:username', limiter(), async (req, res) => {
    if (await noteApp(null).hasLogin(req.params.username)) {
        return res.sendStatus(200);
    } else {
        return res.sendStatus(404);
    }
});

/**
 * Link a wallet
 */
authRouter.post('/link', limiter(), authenticate, jsonParser, async (req, res) => {
    if (req.auth.address !== null) {
        return res.status(400).send('You must be logged in using a username and password to link a wallet');
    }
    try {
        const { address, body } = await Web3Token.verify(req.body.token);
        const id = body['request-id'];
        if (invalidTokens[id]) throw new Error('This token has been invalidated');
        await noteApp(req.auth.user).linkWallet(address);
        return res.status(200).send('Wallet linked to current user');
    } catch (e) {
        return res.status(400).send(e.message);
    }
});

module.exports = {
    authRouter,
    authenticate
};